import { describe, it, expect } from "bun:test";
import { tokenComplete } from "../src/token-complete";

describe("token-complete", () => {
  describe("no splitting needed", () => {
    it("should return input unchanged when within limit (no open tags)", () => {
      const result = tokenComplete("hello world", 100);
      expect(result.completed).toBe("hello world");
      expect(result.overflow).toBe("");
    });

    it("should return input unchanged when exactly at limit", () => {
      const result = tokenComplete("hello", 5);
      expect(result.completed).toBe("hello");
      expect(result.overflow).toBe("");
    });

    it("should close open tags even when within limit (for streaming)", () => {
      const result = tokenComplete("**bold text", 100);
      expect(result.completed).toBe("**bold text**");
      expect(result.overflow).toBe("");
    });

    it("should close multiple open tags when within limit", () => {
      const result = tokenComplete("*italic and **bold", 100);
      expect(result.completed).toBe("*italic and **bold***");
      expect(result.overflow).toBe("");
    });
  });

  describe("bold text (**)", () => {
    it("should close and reopen bold tags when split", () => {
      const input = "**this is bold text**";
      const result = tokenComplete(input, 10);
      expect(result.completed).toBe("**this is **");
      expect(result.overflow).toBe("**bold text**");
    });

    it("should handle unclosed bold at split point", () => {
      const input = "**bold text continues here";
      const result = tokenComplete(input, 8);
      // remend closes at character boundary: "**bold t" -> "**bold t**"
      expect(result.completed).toBe("**bold t**");
      expect(result.overflow).toBe("**ext continues here");
    });
  });

  describe("italic text (*)", () => {
    it("should close and reopen italic tags when split", () => {
      const input = "*this is italic text*";
      const result = tokenComplete(input, 10);
      expect(result.completed).toBe("*this is i*");
      expect(result.overflow).toBe("*talic text*");
    });
  });

  describe("bold + italic (***)", () => {
    it("should close and reopen bold+italic tags when split", () => {
      const input = "***bold and italic***";
      const result = tokenComplete(input, 10);
      expect(result.completed).toBe("***bold an***");
      expect(result.overflow).toBe("***d italic***");
    });
  });

  describe("inline code (`)", () => {
    it("should close and reopen inline code when split", () => {
      const input = "`some code here`";
      const result = tokenComplete(input, 8);
      expect(result.completed).toBe("`some co`");
      expect(result.overflow).toBe("`de here`");
    });
  });

  describe("code blocks (```)", () => {
    // Note: remend does NOT close code blocks with newlines (by design for streaming)
    // So we test inline code block behavior instead
    it("should handle inline code block (no newline)", () => {
      const input = "```code```";
      const result = tokenComplete(input, 6);
      // "```cod" doesn't get closed by remend as it's not a complete pattern
      expect(result.completed).toBe("```cod");
      expect(result.overflow).toBe("e```");
    });
  });

  describe("strikethrough (~~)", () => {
    it("should close and reopen strikethrough when split", () => {
      const input = "~~deleted text here~~";
      const result = tokenComplete(input, 12);
      expect(result.completed).toBe("~~deleted te~~");
      expect(result.overflow).toBe("~~xt here~~");
    });
  });

  describe("underscore bold (__)", () => {
    it("should close and reopen underscore bold when split", () => {
      const input = "__bold text here__";
      const result = tokenComplete(input, 10);
      expect(result.completed).toBe("__bold tex__");
      expect(result.overflow).toBe("__t here__");
    });
  });

  describe("block math ($$)", () => {
    it("should close and reopen block math when split", () => {
      const input = "$$\nx = y + z\n$$";
      const result = tokenComplete(input, 8);
      // remend adds newline before closing $$ for block math
      expect(result.completed).toBe("$$\nx = y\n$$");
      expect(result.overflow).toBe("$$\n + z\n$$");
    });
  });

  describe("nested formatting", () => {
    it("should handle nested bold and italic", () => {
      const input = "**bold *and italic* text**";
      const result = tokenComplete(input, 15);
      // remend should close both tags
      expect(result.completed).toContain("**");
    });
  });

  describe("real-world scenarios", () => {
    it("should handle LLM response split mid-sentence", () => {
      const input = "*this is a sentence generated by a large language model*";
      const result = tokenComplete(input, 20);
      expect(result.completed).toBe("*this is a sentence *");
      expect(result.overflow).toBe("*generated by a large language model*");
    });

    it("should handle multiple paragraphs with formatting", () => {
      const input = "Normal text\n\n**Bold paragraph that is very long**";
      const result = tokenComplete(input, 25);
      // "Normal text\n\n**Bold parag" = 25 chars, remend closes with **
      expect(result.completed).toBe("Normal text\n\n**Bold parag**");
      expect(result.overflow).toBe("**raph that is very long**");
    });
  });
});
