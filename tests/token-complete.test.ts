import { describe, it, expect } from "bun:test";
import { tokenComplete } from "../src/token-complete";

describe("token-complete", () => {
  describe("no splitting needed", () => {
    it("should return input unchanged when within limit (no open tags)", () => {
      const result = tokenComplete("hello world", 100);
      expect(result.completed).toBe("hello world");
      expect(result.overflow).toBe("");
    });

    it("should return input unchanged when exactly at limit", () => {
      const result = tokenComplete("hello", 5);
      expect(result.completed).toBe("hello");
      expect(result.overflow).toBe("");
    });

    it("should close open tags even when within limit (for streaming)", () => {
      const result = tokenComplete("**bold text", 100);
      expect(result.completed).toBe("**bold text**");
      expect(result.overflow).toBe("");
    });

    it("should close multiple open tags when within limit", () => {
      const result = tokenComplete("*italic and **bold", 100);
      expect(result.completed).toBe("*italic and **bold***");
      expect(result.overflow).toBe("");
    });
  });

  describe("bold text (**)", () => {
    it("should close and reopen bold tags when split", () => {
      const input = "**this is bold text**";
      const result = tokenComplete(input, 10);
      expect(result.completed).toBe("**this is **");
      expect(result.overflow).toBe("**bold text**");
    });

    it("should handle unclosed bold at split point", () => {
      const input = "**bold text continues here";
      const result = tokenComplete(input, 8);
      // remend closes at character boundary: "**bold t" -> "**bold t**"
      expect(result.completed).toBe("**bold t**");
      expect(result.overflow).toBe("**ext continues here");
    });
  });

  describe("italic text (*)", () => {
    it("should close and reopen italic tags when split", () => {
      const input = "*this is italic text*";
      const result = tokenComplete(input, 10);
      expect(result.completed).toBe("*this is i*");
      expect(result.overflow).toBe("*talic text*");
    });
  });

  describe("bold + italic (***)", () => {
    it("should close and reopen bold+italic tags when split", () => {
      const input = "***bold and italic***";
      const result = tokenComplete(input, 10);
      expect(result.completed).toBe("***bold an***");
      expect(result.overflow).toBe("***d italic***");
    });
  });

  describe("inline code (`)", () => {
    it("should close and reopen inline code when split", () => {
      const input = "`some code here`";
      const result = tokenComplete(input, 8);
      expect(result.completed).toBe("`some co`");
      expect(result.overflow).toBe("`de here`");
    });
  });

  describe("code blocks (```)", () => {
    // Note: remend does NOT close code blocks with newlines (by design for streaming)
    // So we test inline code block behavior instead
    it("should handle inline code block (no newline)", () => {
      const input = "```code```";
      const result = tokenComplete(input, 6);
      // "```cod" doesn't get closed by remend as it's not a complete pattern
      expect(result.completed).toBe("```cod");
      expect(result.overflow).toBe("e```");
    });
  });

  describe("strikethrough (~~)", () => {
    it("should close and reopen strikethrough when split", () => {
      const input = "~~deleted text here~~";
      const result = tokenComplete(input, 12);
      expect(result.completed).toBe("~~deleted te~~");
      expect(result.overflow).toBe("~~xt here~~");
    });
  });

  describe("underscore bold (__)", () => {
    it("should close and reopen underscore bold when split", () => {
      const input = "__bold text here__";
      const result = tokenComplete(input, 10);
      expect(result.completed).toBe("__bold tex__");
      expect(result.overflow).toBe("__t here__");
    });
  });

  describe("block math ($$)", () => {
    it("should close and reopen block math when split", () => {
      const input = "$$\nx = y + z\n$$";
      const result = tokenComplete(input, 8);
      // remend adds newline before closing $$ for block math
      expect(result.completed).toBe("$$\nx = y\n$$");
      expect(result.overflow).toBe("$$\n + z\n$$");
    });
  });

  describe("nested formatting", () => {
    it("should handle nested bold and italic", () => {
      const input = "**bold *and italic* text**";
      const result = tokenComplete(input, 15);
      // remend should close both tags
      expect(result.completed).toContain("**");
    });
  });

  describe("real-world scenarios", () => {
    it("should handle LLM response split mid-sentence", () => {
      const input = "*this is a sentence generated by a large language model*";
      const result = tokenComplete(input, 20);
      expect(result.completed).toBe("*this is a sentence *");
      expect(result.overflow).toBe("*generated by a large language model*");
    });

    it("should handle multiple paragraphs with formatting", () => {
      const input = "Normal text\n\n**Bold paragraph that is very long**";
      const result = tokenComplete(input, 25);
      // "Normal text\n\n**Bold parag" = 25 chars, remend closes with **
      expect(result.completed).toBe("Normal text\n\n**Bold parag**");
      expect(result.overflow).toBe("**raph that is very long**");
    });
  });

  describe("streaming buffer simulation", () => {
    it("should not accumulate closing tags when simulating streaming chunks", () => {
      // Simulates the discord.ts streaming behavior:
      // - rawBuffer accumulates raw content (no auto-closed tags)
      // - tokenComplete is only used for display
      const maxLength = 100;

      // Chunk 1: "*this is a sentence"
      const chunk1 = "*this is a sentence";
      let rawBuffer = chunk1; // Store raw, NOT completed
      const display1 = tokenComplete(rawBuffer, maxLength).completed;
      expect(display1).toBe("*this is a sentence*"); // Display has closing tag

      // Chunk 2: " generated by a large language model*"
      const chunk2 = " generated by a large language model*";
      rawBuffer = rawBuffer + chunk2; // Accumulate raw content
      const display2 = tokenComplete(rawBuffer, maxLength).completed;

      // Final result should be correct - no duplicate closing tags
      expect(rawBuffer).toBe(
        "*this is a sentence generated by a large language model*",
      );
      expect(display2).toBe(
        "*this is a sentence generated by a large language model*",
      );
    });

    it("should handle overflow case with proper tag continuation", () => {
      const maxLength = 21;

      // Simulate: "*this is a very long bold sentence*"
      // Use maxLength=21 so split happens at a word boundary
      const chunk1 = "*this is a very long bold sentence*";

      // tokenComplete will complete the first 21 chars and provide overflow with opening tags
      const { completed: display1, overflow: overflowPrefix } = tokenComplete(
        chunk1,
        maxLength,
      );

      // First message: "*this is a very long " (21 chars) + "*" (closing)
      expect(display1).toBe("*this is a very long *"); // First message: properly closed
      expect(overflowPrefix).toBe("*bold sentence*"); // Has opening tag for continuation

      // Second message would start with overflowPrefix
      // When stream ends, tokenComplete is applied to get final display
      const finalDisplay2 = tokenComplete(overflowPrefix, maxLength).completed;
      expect(finalDisplay2).toBe("*bold sentence*"); // Second message: properly formatted
    });

    it("should handle multiple overflows correctly", () => {
      const maxLength = 10;

      // Very long bold text that needs multiple splits
      const fullContent = "**this is a very very long bold text**";

      // First split
      const { completed: msg1, overflow: overflow1 } = tokenComplete(
        fullContent,
        maxLength,
      );
      expect(msg1).toBe("**this is **");
      expect(overflow1.startsWith("**")).toBe(true); // Has opening tags

      // Second split (from overflow)
      const { completed: msg2, overflow: overflow2 } = tokenComplete(
        overflow1,
        maxLength,
      );
      expect(msg2).toContain("**"); // Has closing tags
      expect(msg2.endsWith("**")).toBe(true);

      // Continue until done
      let remaining = overflow2;
      const messages = [msg1, msg2];
      while (remaining.length > 0) {
        const { completed, overflow } = tokenComplete(remaining, maxLength);
        messages.push(completed);
        remaining = overflow;
      }

      // All messages should have proper markdown
      for (const msg of messages) {
        const openCount = (msg.match(/\*\*/g) || []).length;
        expect(openCount % 2).toBe(0); // Even number of ** means balanced
      }
    });
  });
});
